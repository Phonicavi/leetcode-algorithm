###空间要求
	空间要求O(1) 如果采用逐一交换的方法则必须要花费更多时间  
	参见rotate2()这个方法 由于每次只能用一块tmp空间故只能移动一位  
	每次移动时间复杂度O(n) 总共移动k次，在已经处理了k=k%n的基础上总的时间复杂度O(n*k) -> O(n^2)  


###时间要求  
	rotate过程最少需要O(n)的时间复杂度 即每一个数都能准确找到对应位的情况下需要移动n次  

	参见rotate()这个方法  

```cpp
int n = nums.size();
k = k%n;
for (int i=0; i<n-k; ++i) nums.push_back(nums[i]);
```

	在原先的nums数组后段添上自己 构成循环数组 后续只需要移动一定位数后取连续段即可  


###其他算法  
	
	例 {1 2 3 4 5 6 7} -> {5 6 7 1 2 3 4}  
	对于给定了n和k的数组来说 k=k%n  
	1. 通过三次reverse完成  
	
		- 翻转前 n-k个数 [4 3 2 1, 5 6 7]  
		- 翻转后 k个数 [4 3 2 1, 7 6 5]  
		- 翻转前 n个数，即整体翻转 [5 6 7 1 2 3 4]  

	2. 